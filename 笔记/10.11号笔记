流式只会对函数模型进行计算，不会存储
数据流可以是集合也可以是数组

limit方法是一个延迟方法  只是对流中的元素进行截取，返回的是一个新的流，可以继续调用其他的方法进行操作
skip  如果长度大于流的长度,那么就返回一个新的元素为0的流

数据结构,先进后出
队列,先进先出
数组,查询快,增删慢,可以快速查找某一个元素 数组的长度是固定不变的
为什么增删慢，必须删除一个数组，重新复制过来
索引  数组的首地址,源数组会在内存中销毁
链表,查询慢，增删快
链表中的每一个元素称之为一个节点，包含了一个书籍源（存储数组）两个指针域（存储地址）
自己的地址，数据，下一个节点的地址

单向链表，链表中只有一条链子，不能保证元素的顺序（存储和取出元素的顺序不一定一致）
双向链表，两条链子，一条链子专门记录元素的顺序，是一个有序的集合

红黑树
树形结构
二叉树分支不超过两个，左孩子，左子树，右孩子，右子树

排序树\查找树
二叉树的基础上，元素是有大小的顺序的。
左子树小，右子树大，

平衡树
左面孩子和右面孩子数量相等
不平衡树

红黑树，特点，趋近于平衡树 查询叶子节点最大次数和最小次数不能超过二部
查询的速度非常快

很多细节卡死人

约束:
1、节点可以是红色的或者黑色的
2、根节点是黑色的
3、叶子节点是黑色的
4、每个红色的节点的子节点都是黑色的
5、任何一个节点到其每一个叶子节点所有路径上黑色节点相同

list Set 集合
ArrayList 底层是一个数组结构,元素增删慢，查找快
LinkedList

Vector 底层也是一个数组，同步的，单线程，速度慢

Set 1不包含重复元素。2没有带索引的方法。也不能使用普通的for循环遍历
HashSet 实现的Set接口，哈希表支持
不允许重复
没有用索引
是一个无序的集合
底层是一个哈希表结构，查询的速度非常快

jdk1.8之后
hashset存储结构哈希表结构
哈希表=数组加链表
哈希表=数组+红黑树（提高查询的速度）

哈希表查询速度快
如果链表长度超过了8位，那么就把链表转换成红黑树，（为了提高查询的速度）

Set为什么不允许存储重复的元素




